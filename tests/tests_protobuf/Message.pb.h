// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Message.proto

#ifndef PROTOBUF_INCLUDED_Message_2eproto
#define PROTOBUF_INCLUDED_Message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#    error This file was generated by a newer version of protoc which is
#    error incompatible with your Protocol Buffer headers.  Please update
#    error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#    error This file was generated by an older version of protoc which is
#    error incompatible with your Protocol Buffer headers.  Please
#    error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/extension_set.h> // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/repeated_field.h> // IWYU pragma: export
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Message_2eproto

namespace protobuf_Message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
    static const ::google::protobuf::internal::ParseTableField entries[];
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
    static const ::google::protobuf::internal::ParseTable schema[1];
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
} // namespace protobuf_Message_2eproto
namespace com {
namespace amazonaws {
namespace iot {
namespace securedtunneling {
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
} // namespace securedtunneling
} // namespace iot
} // namespace amazonaws
} // namespace com
namespace google {
namespace protobuf {
template <>
::com::amazonaws::iot::securedtunneling::Message *Arena::CreateMaybeMessage<
    ::com::amazonaws::iot::securedtunneling::Message>(Arena *);
} // namespace protobuf
} // namespace google
namespace com {
namespace amazonaws {
namespace iot {
namespace securedtunneling {

enum Message_Type {
    Message_Type_UNKNOWN = 0,
    Message_Type_DATA = 1,
    Message_Type_STREAM_START = 2,
    Message_Type_STREAM_RESET = 3,
    Message_Type_SESSION_RESET = 4,
    Message_Type_Message_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
    Message_Type_Message_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_UNKNOWN;
const Message_Type Message_Type_Type_MAX = Message_Type_SESSION_RESET;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

// ===================================================================

class Message
    : public ::google::protobuf::
          MessageLite /* @@protoc_insertion_point(class_definition:com.amazonaws.iot.securedtunneling.Message) */ {
  public:
    Message();
    virtual ~Message();

    Message(const Message &from);

    inline Message &operator=(const Message &from) {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    Message(Message &&from) noexcept : Message() { *this = ::std::move(from); }

    inline Message &operator=(Message &&from) noexcept {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    static const Message &default_instance();

    static void InitAsDefaultInstance(); // FOR INTERNAL USE ONLY
    static inline const Message *internal_default_instance() {
        return reinterpret_cast<const Message *>(&_Message_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(Message *other);
    friend void swap(Message &a, Message &b) { a.Swap(&b); }

    // implements Message ----------------------------------------------

    inline Message *New() const final { return CreateMaybeMessage<Message>(NULL); }

    Message *New(::google::protobuf::Arena *arena) const final { return CreateMaybeMessage<Message>(arena); }
    void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite &from) final;
    void CopyFrom(const Message &from);
    void MergeFrom(const Message &from);
    void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
    bool MergePartialFromCodedStream(::google::protobuf::io::CodedInputStream *input) final;
    void SerializeWithCachedSizes(::google::protobuf::io::CodedOutputStream *output) const final;
    void DiscardUnknownFields();
    int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const;
    void InternalSwap(Message *other);

  private:
    inline ::google::protobuf::Arena *GetArenaNoVirtual() const { return NULL; }
    inline void *MaybeArenaPtr() const { return NULL; }

  public:
    ::std::string GetTypeName() const final;

    // nested types ----------------------------------------------------

    typedef Message_Type Type;
    static const Type UNKNOWN = Message_Type_UNKNOWN;
    static const Type DATA = Message_Type_DATA;
    static const Type STREAM_START = Message_Type_STREAM_START;
    static const Type STREAM_RESET = Message_Type_STREAM_RESET;
    static const Type SESSION_RESET = Message_Type_SESSION_RESET;
    static inline bool Type_IsValid(int value) { return Message_Type_IsValid(value); }
    static const Type Type_MIN = Message_Type_Type_MIN;
    static const Type Type_MAX = Message_Type_Type_MAX;
    static const int Type_ARRAYSIZE = Message_Type_Type_ARRAYSIZE;

    // accessors -------------------------------------------------------

    // bytes payload = 4;
    void clear_payload();
    static const int kPayloadFieldNumber = 4;
    const ::std::string &payload() const;
    void set_payload(const ::std::string &value);
#if LANG_CXX11
    void set_payload(::std::string &&value);
#endif
    void set_payload(const char *value);
    void set_payload(const void *value, size_t size);
    ::std::string *mutable_payload();
    ::std::string *release_payload();
    void set_allocated_payload(::std::string *payload);

    // .com.amazonaws.iot.securedtunneling.Message.Type type = 1;
    void clear_type();
    static const int kTypeFieldNumber = 1;
    ::com::amazonaws::iot::securedtunneling::Message_Type type() const;
    void set_type(::com::amazonaws::iot::securedtunneling::Message_Type value);

    // int32 streamId = 2;
    void clear_streamid();
    static const int kStreamIdFieldNumber = 2;
    ::google::protobuf::int32 streamid() const;
    void set_streamid(::google::protobuf::int32 value);

    // bool ignorable = 3;
    void clear_ignorable();
    static const int kIgnorableFieldNumber = 3;
    bool ignorable() const;
    void set_ignorable(bool value);

    // @@protoc_insertion_point(class_scope:com.amazonaws.iot.securedtunneling.Message)
  private:
    ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
    ::google::protobuf::internal::ArenaStringPtr payload_;
    int type_;
    ::google::protobuf::int32 streamid_;
    bool ignorable_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    friend struct ::protobuf_Message_2eproto::TableStruct;
};
// ===================================================================

// ===================================================================

#ifdef __GNUC__
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif // __GNUC__
// Message

// .com.amazonaws.iot.securedtunneling.Message.Type type = 1;
inline void Message::clear_type() {
    type_ = 0;
}
inline ::com::amazonaws::iot::securedtunneling::Message_Type Message::type() const {
    // @@protoc_insertion_point(field_get:com.amazonaws.iot.securedtunneling.Message.type)
    return static_cast<::com::amazonaws::iot::securedtunneling::Message_Type>(type_);
}
inline void Message::set_type(::com::amazonaws::iot::securedtunneling::Message_Type value) {

    type_ = value;
    // @@protoc_insertion_point(field_set:com.amazonaws.iot.securedtunneling.Message.type)
}

// int32 streamId = 2;
inline void Message::clear_streamid() {
    streamid_ = 0;
}
inline ::google::protobuf::int32 Message::streamid() const {
    // @@protoc_insertion_point(field_get:com.amazonaws.iot.securedtunneling.Message.streamId)
    return streamid_;
}
inline void Message::set_streamid(::google::protobuf::int32 value) {

    streamid_ = value;
    // @@protoc_insertion_point(field_set:com.amazonaws.iot.securedtunneling.Message.streamId)
}

// bool ignorable = 3;
inline void Message::clear_ignorable() {
    ignorable_ = false;
}
inline bool Message::ignorable() const {
    // @@protoc_insertion_point(field_get:com.amazonaws.iot.securedtunneling.Message.ignorable)
    return ignorable_;
}
inline void Message::set_ignorable(bool value) {

    ignorable_ = value;
    // @@protoc_insertion_point(field_set:com.amazonaws.iot.securedtunneling.Message.ignorable)
}

// bytes payload = 4;
inline void Message::clear_payload() {
    payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string &Message::payload() const {
    // @@protoc_insertion_point(field_get:com.amazonaws.iot.securedtunneling.Message.payload)
    return payload_.GetNoArena();
}
inline void Message::set_payload(const ::std::string &value) {

    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:com.amazonaws.iot.securedtunneling.Message.payload)
}
#if LANG_CXX11
inline void Message::set_payload(::std::string &&value) {

    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:com.amazonaws.iot.securedtunneling.Message.payload)
}
#endif
inline void Message::set_payload(const char *value) {
    GOOGLE_DCHECK(value != NULL);

    payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:com.amazonaws.iot.securedtunneling.Message.payload)
}
inline void Message::set_payload(const void *value, size_t size) {

    payload_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char *>(value), size));
    // @@protoc_insertion_point(field_set_pointer:com.amazonaws.iot.securedtunneling.Message.payload)
}
inline ::std::string *Message::mutable_payload() {

    // @@protoc_insertion_point(field_mutable:com.amazonaws.iot.securedtunneling.Message.payload)
    return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string *Message::release_payload() {
    // @@protoc_insertion_point(field_release:com.amazonaws.iot.securedtunneling.Message.payload)

    return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_payload(::std::string *payload) {
    if (payload != NULL) {

    } else {
    }
    payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
    // @@protoc_insertion_point(field_set_allocated:com.amazonaws.iot.securedtunneling.Message.payload)
}

#ifdef __GNUC__
#    pragma GCC diagnostic pop
#endif // __GNUC__

// @@protoc_insertion_point(namespace_scope)

} // namespace securedtunneling
} // namespace iot
} // namespace amazonaws
} // namespace com

namespace google {
namespace protobuf {

template <> struct is_proto_enum<::com::amazonaws::iot::securedtunneling::Message_Type> : ::std::true_type {};

} // namespace protobuf
} // namespace google

// @@protoc_insertion_point(global_scope)

#endif // PROTOBUF_INCLUDED_Message_2eproto
